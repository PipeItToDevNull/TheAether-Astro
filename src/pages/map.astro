---
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import { getCollection, render } from 'astro:content';

const maps = await getCollection('maps');
const mapPage = maps.find((m) => m.id === '002-network-map') || maps[0];
const { Content, headings } = await render(mapPage);
---

<StarlightPage frontmatter={{ title: mapPage?.data?.title ?? 'Network Map' }} headings={headings}>
  <Content />

  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });

    const SELECTORS = [
      'pre > code.language-mermaid',
      'code.language-mermaid',
      'pre > code[class*="language-mermaid"]',
      'div.language-mermaid',
      'pre' // fallback â€” will inspect contents
    ].join(',');

    function sanitize(text = '') {
      return text
        .replace(/\uFEFF/g, '')
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/[\u201C\u201D]/g, '"')
        .replace(/\u00A0/g, ' ')
        .replace(/\r\n?/g, '\n')
        .replace(/\t/g, ' ')
        .replace(/[ \u00A0]+/g, ' ')
        .trim();
    }

    function looksLikeMermaid(text) {
      return /(?:^|\n)\s*(?:graph|flowchart|sequenceDiagram|classDiagram|stateDiagram|gitGraph|gantt|erDiagram|pie|journey)\b/i.test(text);
    }

    function getTextFromNode(node) {
      // prefer innerText for rendered newlines; fall back to textContent
      return (node.innerText || node.textContent || '').trim();
    }

    function tryConvert(node) {
      const raw = getTextFromNode(node);
      if (!raw) return false;
      const clean = sanitize(raw);
      if (!looksLikeMermaid(clean)) return false;

      console.info('Mermaid candidate:', { classes: node.className, snippet: clean.slice(0, 200) });

      try {
        mermaid.parse(clean);
      } catch (err) {
        console.error('Mermaid parse error (sanitized):', err.message || err, '\nSnippet:', clean.slice(0, 1000));
        return false;
      }

      const wrapper = node.closest('pre') || node;
      const mer = document.createElement('div');
      mer.className = 'mermaid';
      mer.textContent = clean;
      wrapper.replaceWith(mer);

      try {
        mermaid.init(undefined, [mer]);
        console.info('Mermaid rendered.');
      } catch (err) {
        console.error('Mermaid render error:', err);
      }
      return true;
    }

    function convertAll() {
      const nodes = Array.from(document.querySelectorAll(SELECTORS));
      console.debug('Mermaid: found candidate nodes count=', nodes.length);
      let converted = 0;
      for (const n of nodes) {
        // if node is a generic <pre>, try to find its <code> child first
        const candidate = n.tagName?.toLowerCase() === 'pre' ? (n.querySelector('code') || n) : n;
        if (tryConvert(candidate)) converted++;
      }
      console.debug('Mermaid: converted count=', converted);
      return converted;
    }

    // initial attempt
    setTimeout(() => {
      const c = convertAll();
      if (c === 0) console.debug('Mermaid: no conversions on initial pass');
    }, 50);

    // observe DOM mutations (for syntax highlighters / delayed renderers)
    const obs = new MutationObserver((mutations) => {
      let added = false;
      for (const m of mutations) if (m.addedNodes && m.addedNodes.length) { added = true; break; }
      if (!added) return;
      clearTimeout(window.__mermaidConvertTimeout);
      window.__mermaidConvertTimeout = setTimeout(() => {
        const c = convertAll();
        if (c > 0) obs.disconnect();
      }, 120);
    });
    obs.observe(document.documentElement || document.body, { childList: true, subtree: true });

    // final fallback
    setTimeout(() => { convertAll(); obs.disconnect(); }, 2000);
  </script>

  <style>
    .mermaid { margin: 1rem 0; }
  </style>
</StarlightPage>